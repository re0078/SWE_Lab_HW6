# آزمایش پنجم آزمایشگاه مهندسی نرم‌افزار
## توضیحات آزمایش
<p align="justify">
برای انجام این آزمایش ما برای پیاده‌سازی الگوهای abstract factory، prototype و builder به این صورت عمل کردیم که نخست کلاس تست را طبق روش TDD پیاده‌سازی کرده سپس این تست‌ها را کامپایل می‌کنیم و ایرادهای آن را شناسایی می‌کنیم و با اضافه کردن کد در برنامه اصلی ارور‌های کامپایلی آن را از بین می‌بریم و دوباره تست‌ها را اجرا می‌کنیم و این سری با اجرای تست‌ها به ارور‌های زمان اجرا بر می‌خوریم و آن‌ها را از بین می‌بریم.
</p>

## مراحل انجام آزمایش

### الگوی abstract factory
<p align="justify">
همانطور که گفته شده است ابتدا تست‌ها برای کلاس‌های abstract factory پیاده‌سازی می‌کنیم. سناریو پیاده‌سازی شده مرتبط با ویدیو است. این سناریو به صورت زیر است:

  ![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/05538c17-7edb-468f-84ef-df5e9095c595)
  
با پیاده‌سازی تست‌ها و اجرای آن برنامه ما به خطای کامپایلی خورد زیرا هنوز کدی پیاده‌سازی نشده است. مانند تصویر زیر:

  ![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/4cddc140-565e-4254-b3c9-1126ee3071b8)
  
  سپس کلاس‌های مورد نیاز به org.example.abstractfactorypattern اضافه می ‌شود در نتیجه تست‌ها بدون هیچ اروری اجرا می‌شوند. مانند تصویر زیر:
  ![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/0759ba6c-fc99-4837-a968-269b79bafd33)
  
</p>

### الگوی prototype

<p align="justify">
  همانطور که گفته شده است ابتدا تست‌ها برای کلاس‌های prototype پیاده‌سازی می‌کنیم. سناریو پیاده‌سازی شده در مورد شبیه‌سازی یک دایره ایجاد شده با latitude،  longitude و شعاع است با پیاده‌سازی تست‌ها و اجرای آن برنامه ما به خطای کامپایلی خورد زیرا هنوز کدی پیاده‌سازی نشده است. مانند تصویر زیر:
  
  ![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/6e64bb04-b496-42a3-b976-995d04d9aad4)

  سپس کلاس‌ مورد نیاز به org.example.prototypepattern اضافه می ‌شود در نتیجه تست‌ها بدون هیچ اروری اجرا می‌شوند. مانند تصویر زیر:
  
![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/5d02ae1a-e7b1-4d3f-8381-b11f48325fd4)  
</p>

### الگوی builder

<p align="justify">
همانطور که گفته شده است ابتدا تست‌ها برای کلاس‌های builder پیاده‌سازی می‌کنیم. سناریو پیاده‌سازی شده در مورد ایجاد یک سفارش خرید با قابلیت customize کردن است با پیاده‌سازی تست‌ها و اجرای آن برنامه ما به خطای کامپایلی خورد زیرا هنوز کدی پیاده‌سازی نشده است. مانند تصویر زیر:
  
![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/3bb4047a-0715-4ea0-8da6-8e62b31b8469)
  
سپس کلاس‌ مورد نیاز به org.example.builderpattern اضافه می ‌شود در نتیجه تست‌ها بدون هیچ اروری اجرا می‌شوند. مانند تصویر زیر:
  
![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/af24cb3c-d3c8-49a4-b3c7-40c61fc9243c)  
  
</p>

### پیاده‌سازی نهایی
<p align="justify">
  بعد از پیاده‌سازی نهایی به منظور اطمینان تمام تست‌ها را اجرا می‌کنیم و همانطور که در تصویر زیر مشخص است، تمام تست‌ها بدون ارور اجرا می‌شود:
  
  ![](https://github.com/re0078/SWE_Lab_HW6/assets/59199865/4971e986-54db-463e-967f-4b7871af2a4d)
  </p>

## پرسش‌ها
### سوال ۱

<p dir="rtl" align="justify">
<i>
creational patterns
</i>
این الگو مکانیزم‌هایی برای تولید object تعریف می‌کند که انعطاف‌پذیری و استفاده دوباره از کد بالا رود.
</p>
  
<p dir="rtl" align="justify">
<i>
structural patterns
</i>.
  این الگو به ما می‌گوید چگونه داخل یک structure بزرگ classها و objectهایمان را پیاده کنیم به طوری که اون structure انعطاف پذیر و کارا بماند.
</p>

<p dir="rtl" align="justify">
<i>
behavioral patterns
</i>
این الگو با الگوریتم‌ها و تخصیص مسئولیت‌ها بین اشیا سروکار دارند.
</p>


### سوال ۲

سه الگو بیان شده در این آزمایش مربوط به دسته creational pattern است.


### سوال ۳
<p align="justify">
به طور کلی اصول SOLID مجموعه‌ای از اصول است که به ما نمی‌گوید دقیقا چگونه کدمان را پیاده کنیم بلکه می‌گوید کد باید این ویژگی‌‌ها را داشته باشد. اما Design Patternها به ما به طور خاص به ما می‌گویند که چگونه کدمان را طراحی کنیم تا به هدفی خاص برسیم.
به بیانی دیگر اصول SOLID مجموعه ای از اصول هستند که به طراحی بهتر سیستم‌های شی گرا کمک می‌کنند. از سوی دیگر، الگوهای طراحی GoF راه‌حل‌های طراحی اثبات شده برای مشکلات تکراری هستند. در حالی که اصول SOLID به هیچ حوزه مشکل خاصی مرتبط نیستند و در هر سناریویی صادق هستند، الگوهای طراحی GoF راه‌حل‌های خاصی برای مشکلات خاص هستند.
</p>

### سوال ۴
<p align="justify">
  الگوی طراحی Singleton یک الگوی creational است که برای اطمینان از اینکه تنها یک نمونه از یک کلاس در یک زبان شی‌گرا وجود دارد استفاده می‌شود. بحث‌هایی در مورد اینکه آیا الگوی Singleton هر یک از اصول SOLID را نقض می کند وجود دارد.
</p>
<p align="justify">
  برخی استدلال می‌کنند که الگوی Singleton می‌تواند اصل open/close یا همان OCP را نقض کند، زیرا معمولا به‌گونه‌ای پیاده‌سازی می‌شود که از وراثت جلوگیری می‌کند. با این حال، دیگران استدلال می‌کنند که ذاتاً OCP را نقض نمی‌کند و اتفاقاً اغلب در نقض OCP توسط توسعه‌دهندگانی که کتاب GoF را نخوانده‌اند اجرا می‌شود.
</p>
<p align="justify">
همچنین بحث‌هایی در مورد اینکه آیا الگوی Singleton اصل signle responsibility یا همان SRP را نقض می‌کند، وجود دارد. برخی استدلال می‌کنند که این کار را انجام می دهد زیرا creation و life cycle خود را کنترل می‌کند. با این حال، دیگران استدلال می‌کنند که SRP را نقض نمی‌کند، زیرا محدود کردن تنها یک شی ربطی به عملکرد کلاس ندارد.
</p>





